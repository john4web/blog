<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on gersti.at</title>
    <link>https://gersti.at/posts/</link>
    <description>Recent content in Posts on gersti.at</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 05 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://gersti.at/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Polymorphism and dynamic binding</title>
      <link>https://gersti.at/posts/polymorphism/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gersti.at/posts/polymorphism/</guid>
      <description>By changing its color, a chameleon can take on different states – similar to an object in programming (Source: Pexels).
Overview Link to heading Polymorphism, along with encapsulation and inheritance, is a fundamental concept of object-oriented programming. But what exactly is polymorphism? This blog article aims to answer that question. Essentially, there are two types of polymorphism – static and dynamic polymorphism.
Static Polymorphism (Compile-Time Polymorphism) Link to heading This is normal method overloading.</description>
    </item>
    
    <item>
      <title>The Strategy Pattern</title>
      <link>https://gersti.at/posts/strategy-pattern/</link>
      <pubDate>Thu, 12 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gersti.at/posts/strategy-pattern/</guid>
      <description>This blog post offers an explanation of Strategy Design Pattern by Gang of Four. The examples are written in Java.
A duck can fly and quack (and can do probably much more things). Image-Source: Pixabay
The Problem that the strategy pattern solves Link to heading Let&amp;rsquo;s say we have a Duck class. And then we have a CityDuck (living in the city) and a WildDuck (living in the forest). We use inheritance – so CityDuck and WildDuck inherit from Duck.</description>
    </item>
    
    <item>
      <title>Liskov substitution principle and DbC in depth</title>
      <link>https://gersti.at/posts/liskov-substitution-principle/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gersti.at/posts/liskov-substitution-principle/</guid>
      <description>This blog post offers a detailed explanation of the liskov substitution principle and gives an overview of the rules you should follow as a software engineer when dealing with inheritance in object-oriented programming to produce clean code. The following is a summary of some sources I have read however also includes my own opinion and knowledge on that topic. Code examples are written in Java.
Overview Link to heading The Liskov Substitution Principle (LSP) was first introduced by Barbara Liskov in 1987 in her article &amp;ldquo;Data Abstraction and Hierarchy&amp;rdquo; and is one of the five SOLID design principles of object-oriented programming.</description>
    </item>
    
    <item>
      <title>Stream API</title>
      <link>https://gersti.at/posts/stream-api/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://gersti.at/posts/stream-api/</guid>
      <description>A stream in a forest (Source: Pexels).
Overview Link to heading Java Streams were introduced in Java 8 and are a very powerful concept. They provide a set of functions that you can perform on certain data structures. They allow you to quickly and conveniently perform operations on them. Streams themselves are not data structures and they do not modify the underlying data structures they are operating on.
Streams do all the heavy lifting for you.</description>
    </item>
    
  </channel>
</rss>
